<!--
doc/src/sgml/ref/create_type.sgml
PostgreSQL documentation
-->

<refentry id="SQL-CREATETYPE">
 <refmeta>
  <refentrytitle>CREATE TYPE</refentrytitle>
  <manvolnum>7</manvolnum>
  <!--
<refmiscinfo>SQL - Language Statements</refmiscinfo>
-->
<refmiscinfo>SQL - 语句</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE TYPE</refname>
  <!--
  <refpurpose>define a new data type</refpurpose>
  -->
  <refpurpose>定义一个新数据类型</refpurpose>
 </refnamediv>

 <indexterm zone="sql-createtype">
  <primary>CREATE TYPE</primary>
 </indexterm>

 <refsynopsisdiv>
<synopsis>
CREATE TYPE <replaceable class="parameter">name</replaceable> AS
    ( [ <replaceable class="PARAMETER">attribute_name</replaceable> <replaceable class="PARAMETER">data_type</replaceable> [ COLLATE <replaceable>collation</replaceable> ] [, ... ] ] )

CREATE TYPE <replaceable class="parameter">name</replaceable> AS ENUM
    ( [ '<replaceable class="parameter">label</replaceable>' [, ... ] ] )

CREATE TYPE <replaceable class="parameter">name</replaceable> AS RANGE (
    SUBTYPE = <replaceable class="parameter">subtype</replaceable>
    [ , SUBTYPE_OPCLASS = <replaceable class="parameter">subtype_operator_class</replaceable> ]
    [ , COLLATION = <replaceable class="parameter">collation</replaceable> ]
    [ , CANONICAL = <replaceable class="parameter">canonical_function</replaceable> ]
    [ , SUBTYPE_DIFF = <replaceable class="parameter">subtype_diff_function</replaceable> ]
)

CREATE TYPE <replaceable class="parameter">name</replaceable> (
    INPUT = <replaceable class="parameter">input_function</replaceable>,
    OUTPUT = <replaceable class="parameter">output_function</replaceable>
    [ , RECEIVE = <replaceable class="parameter">receive_function</replaceable> ]
    [ , SEND = <replaceable class="parameter">send_function</replaceable> ]
    [ , TYPMOD_IN = <replaceable class="parameter">type_modifier_input_function</replaceable> ]
    [ , TYPMOD_OUT = <replaceable class="parameter">type_modifier_output_function</replaceable> ]
    [ , ANALYZE = <replaceable class="parameter">analyze_function</replaceable> ]
    [ , INTERNALLENGTH = { <replaceable class="parameter">internallength</replaceable> | VARIABLE } ]
    [ , PASSEDBYVALUE ]
    [ , ALIGNMENT = <replaceable class="parameter">alignment</replaceable> ]
    [ , STORAGE = <replaceable class="parameter">storage</replaceable> ]
    [ , LIKE = <replaceable class="parameter">like_type</replaceable> ]
    [ , CATEGORY = <replaceable class="parameter">category</replaceable> ]
    [ , PREFERRED = <replaceable class="parameter">preferred</replaceable> ]
    [ , DEFAULT = <replaceable class="parameter">default</replaceable> ]
    [ , ELEMENT = <replaceable class="parameter">element</replaceable> ]
    [ , DELIMITER = <replaceable class="parameter">delimiter</replaceable> ]
    [ , COLLATABLE = <replaceable class="parameter">collatable</replaceable> ]
)

CREATE TYPE <replaceable class="parameter">name</replaceable>
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <command>CREATE TYPE</command> registers a new data type for use in
   the current database.  The user who defines a type becomes its
   owner.
  </para>
-->
<para>
<command>CREATE TYPE</command>为当前数据库注册一个新的数据类型。
定义该类型的用户成为其所有者。
</para>

  <!--
<para>
   If a schema name is given then the type is created in the specified
   schema.  Otherwise it is created in the current schema.  The type
   name must be distinct from the name of any existing type or domain
   in the same schema.  (Because tables have associated data types,
   the type name must also be distinct from the name of any existing
   table in the same schema.)
  </para>
-->
<para>
如果给出模式名，那么该类型是在指定模式中创建。否则它将在当前模式中创建。
类型名必需和同一模式中任何现有的类型或者域不同。（因为表和数据类型有联系，
所以类型名也不能和同模式中的表名字冲突。）
</para>

  <!--
<para>
   There are five forms of <command>CREATE TYPE</command>, as shown in the
   syntax synopsis above.  They respectively create a <firstterm>composite
   type</>, an <firstterm>enum type</>, a <firstterm>range type</>, a
   <firstterm>base type</>, or a <firstterm>shell type</>.  The first four
   of these are discussed in turn below.  A shell type is simply a placeholder
   for a type to be defined later; it is created by issuing <command>CREATE
   TYPE</command> with no parameters except for the type name.  Shell types
   are needed as forward references when creating range types and base types,
   as discussed in those sections.
  </para>
-->
<para>
有5种形式的<command>CREATE TYPE</command>，显示在上面的语法摘要里。
他们分别创建<firstterm>复合类型</>、<firstterm>枚举类型</>、
<firstterm>范围类型</>、<firstterm>基本类型</>或<firstterm>壳类型</>。
前四个在下面依次讨论。壳类型是简单的一个稍后定义的类型的占位符；
通过发出没有参数只有类型名的<command>CREATE TYPE</command>创建。
当创建范围类型和基本类型时，壳类型作为向前引用需要，在下面章节中讨论。
</para>

  <refsect2>
   <!--
   <title>Composite Types</title>
   -->
   <title>复合类型</title>

  <!--
<para>
   The first form of <command>CREATE TYPE</command>
   creates a composite type.
   The composite type is specified by a list of attribute names and data types.
   An attribute's collation can be specified too, if its data type is
   collatable.  A composite type is essentially the same as the row type
   of a table, but using <command>CREATE TYPE</command> avoids the need to
   create an actual table when all that is wanted is to define a type.
   A stand-alone composite type is useful, for example, as the argument or
   return type of a function.
  </para>
-->
<para>
<command>CREATE TYPE</command>的第一种形式创建一个复合类型。
复合类型是通过一列属性名和数据类型声明的。如果它的数据类型可排序，
那么也可以指定属性的排序。复合类型本质上和一个表的行类型一样，
但是如果只是想定义一个类型，那么使用<command>CREATE TYPE</command>
就可以避免直接创建实际的表。一个独立的复合类型是有用的，例如，
做为一个函数的参数或者返回类型。
</para>

  <!--
<para>
   To be able to create a composite type, you must
   have <literal>USAGE</literal> privilege on all attribute types.
  </para>
-->
<para>
要想能够创建一个复合类型，必须在所有的属性类型上有<literal>USAGE</literal>权限。
</para>
  </refsect2>

  <refsect2 id="SQL-CREATETYPE-enum">
   <!--
   <title>Enumerated Types</title>
   -->
   <title>枚举类型</title>

   <!--
<para>
    The second form of <command>CREATE TYPE</command> creates an enumerated
    (enum) type, as described in <xref linkend="datatype-enum">.
    Enum types take a list of one or more quoted labels, each of which
    must be less than <symbol>NAMEDATALEN</symbol> bytes long (64 bytes in a
    standard <productname>PostgreSQL</productname> build).
   </para>
-->
<para>
<command>CREATE TYPE</command>的第二种形式创建一个枚举（enum）类型，
在<xref linkend="datatype-enum">中描述。枚举类型接受一个或更多的引用标签的列表，
每个标签必须小于<symbol>NAMEDATALEN</symbol>字节长度
（在标准的<productname>PostgreSQL</productname>建立中是64字节）。
</para>
  </refsect2>

  <refsect2 id="SQL-CREATETYPE-RANGE">
   <!-- 
   <title>Range Types</title>
   -->
   <title>范围类型</title>

   <!--
<para>
    The third form of <command>CREATE TYPE</command> creates a new
    range type, as described in <xref linkend="rangetypes">.
   </para>
-->
<para>
<command>CREATE TYPE</command>的第三种形式创建一个新的范围类型，
在<xref linkend="rangetypes">中描述。
</para>

   <!--
<para>
    The range type's <replaceable class="parameter">subtype</replaceable> can
    be any type with an associated b-tree operator class (to determine the
    ordering of values for the range type).  Normally the subtype's default
    b-tree operator class is used to determine ordering; to use a non-default
    operator class, specify its name with <replaceable
    class="parameter">subtype_opclass</replaceable>.  If the subtype is
    collatable, and you want to use a non-default collation in the range's
    ordering, specify the desired collation with the <replaceable
    class="parameter">collation</replaceable> option.
   </para>
-->
<para>
范围类型的<replaceable class="parameter">subtype</replaceable>
可以是有一个相关的b-tree操作符类（决定范围类型值的顺序）的任意类型。
通常子类型的缺省b-tree操作符类用于决定顺序；要使用一个非缺省的操作符类，
用<replaceable class="parameter">subtype_opclass</replaceable>指定它的名字。
如果子类型是可排序的，并且你希望在范围的排序中使用非缺省的排序，
那么使用<replaceable class="parameter">collation</replaceable>
选项指定想要的排序。
</para>

   <!--
<para>
    The optional <replaceable class="parameter">canonical</replaceable>
    function must take one argument of the range type being defined, and
    return a value of the same type.  This is used to convert range values
    to a canonical form, when applicable.  See <xref
    linkend="rangetypes-defining"> for more information.  Creating a
    <replaceable class="parameter">canonical</replaceable> function
    is a bit tricky, since it must be defined before the range type can be
    declared.  To do this, you must first create a shell type, which is a
    placeholder type that has no properties except a name and an
    owner.  This is done by issuing the command <literal>CREATE TYPE
    <replaceable>name</></literal>, with no additional parameters.  Then
    the function can be declared using the shell type as argument and result,
    and finally the range type can be declared using the same name.  This
    automatically replaces the shell type entry with a valid range type.
   </para>
-->
<para>
可选的<replaceable class="parameter">canonical</replaceable>
函数必须接受一个被定义的范围类型的参数，并且返回相同类型的值。
适用时，这用于转换范围类型到标准形式。参阅<xref linkend="rangetypes-defining">
获取更多信息。创建一个<replaceable class="parameter">canonical</replaceable>
函数比较棘手，因为它必须在范围类型可以被声明之前定义。要做到这点，
必须先创建一个壳类型，壳类型是一个除了名字和所有者之外没有其他属性的占位符类型。
这可以通过发出没有其他额外参数的<literal>CREATE TYPE <replaceable>name</></literal>命令来完成。
然后可以使用该壳类型作为参数和结果声明该函数，最后可以使用相同的名字声明范围类型。
这将自动使用有效的范围类型替代壳类型条目。
</para>

   <!--
<para>
    The optional <replaceable class="parameter">subtype_diff</replaceable>
    function must take two values of the
    <replaceable class="parameter">subtype</replaceable> type as argument,
    and return a <type>double precision</type> value representing the
    difference between the two given values.  While this is optional,
    providing it allows much greater efficiency of GiST indexes on columns of
    the range type.  See <xref linkend="rangetypes-defining"> for more
    information.
   </para>
-->
<para>
可选的<replaceable class="parameter">subtype_diff</replaceable>函数必须接受两个
<replaceable class="parameter">subtype</replaceable>类型的值作为参数，
并且返回<type>双精度</type>值表示两个给定值之间的不同。
虽然这是可选的，但是提供它允许GiST索引在范围类型字段上有更大的效率。
参阅<xref linkend="rangetypes-defining">获取更多信息。
</para>
  </refsect2>

  <refsect2>
   <!-- 
   <title>Base Types</title>
   -->
   <title>基本类型</title>

  <!--
<para>
   The fourth form of <command>CREATE TYPE</command> creates a new base type
   (scalar type).  To create a new base type, you must be a superuser.
   (This restriction is made because an erroneous type definition could
   confuse or even crash the server.)
  </para>
-->
<para>
<command>CREATE TYPE</command>的第四种形式创建一个新的基本类型(标量类型)。
要创建一个新的基本类型，你必须是一个超级用户。
（做这个限制是因为一个错误的类型定义会混淆或者甚至崩溃服务器。）
</para>

  <!--
<para>
   The parameters can appear in any order, not only that
   illustrated above, and most are optional.  You must register
   two or more functions (using <command>CREATE FUNCTION</command>) before
   defining the type.  The support functions
   <replaceable class="parameter">input_function</replaceable> and
   <replaceable class="parameter">output_function</replaceable>
   are required, while the functions
   <replaceable class="parameter">receive_function</replaceable>,
   <replaceable class="parameter">send_function</replaceable>,
   <replaceable class="parameter">type_modifier_input_function</replaceable>,
   <replaceable class="parameter">type_modifier_output_function</replaceable> and
   <replaceable class="parameter">analyze_function</replaceable>
   are optional.  Generally these functions have to be coded in C
   or another low-level language.
  </para>
-->
<para>
参数可以按任意顺序出现，而不是上面显示的那样，并且大多数都是可选的。
必须在定义类型之前先用<command>CREATE FUNCTION</command>注册两个或更多个函数。
支持函数<replaceable class="parameter">input_function</replaceable>
和<replaceable class="parameter">output_function</replaceable>是必须的，
而函数<replaceable class="parameter">receive_function</replaceable>、
<replaceable class="parameter">send_function</replaceable>、
<replaceable class="parameter">type_modifier_input_function</replaceable>、
<replaceable class="parameter">type_modifier_output_function</replaceable>
和<replaceable class="parameter">analyze_function</replaceable>是可选的。
通常，这些函数必须用 C 或者其它低层语言编写。
</para>

  <!--
<para>
   The <replaceable class="parameter">input_function</replaceable>
   converts the type's external textual representation to the internal
   representation used by the operators and functions defined for the type.
   <replaceable class="parameter">output_function</replaceable>
   performs the reverse transformation.  The input function can be
   declared as taking one argument of type <type>cstring</type>,
   or as taking three arguments of types
   <type>cstring</type>, <type>oid</type>, <type>integer</type>.
   The first argument is the input text as a C string, the second
   argument is the type's own OID (except for array types, which instead
   receive their element type's OID),
   and the third is the <literal>typmod</> of the destination column, if known
   (-1 will be passed if not).
   The input function must return a value of the data type itself.
   Usually, an input function should be declared STRICT; if it is not,
   it will be called with a NULL first parameter when reading a NULL
   input value.  The function must still return NULL in this case, unless
   it raises an error.
   (This case is mainly meant to support domain input functions, which
   might need to reject NULL inputs.)
   The output function must be
   declared as taking one argument of the new data type.
   The output function must return type <type>cstring</type>.
   Output functions are not invoked for NULL values.
  </para>
-->
<para>
<replaceable class="parameter">input_function</replaceable>
函数将该类型的外部文本形式转换成可以被该类型的操作符和函数识别的内部形式。
<replaceable class="parameter">output_function</replaceable>用途相反。
输入函数可以声明为接受一个类型为<type>cstring</type>的参数，
或者接受三个类型分别为<type>cstring</type>、<type>oid</type>、
<type>integer</type>的参数。第一个参数是 C 字符串形式的输入文本，
第二个参数是该类型自身的 OID(数组类型除外，这种情况下它们接受自身元素的类型 OID)，
第三个是目标字段的<literal>typmod</>(如果未知则传递 -1)。
输入函数必须返回一个自身数据类型的值。通常，输入函数应当被声明为 STRICT ，
否则当读取 NULL 输入时将被使用第一个参数为 NULL 进行调用，
并且必须仍然返回 NULL 或报错。（这个特性主要是为了支持域输入函数，
这种函数可能需要拒绝 NULL 输入。）输出函数必须被声明为接受一个新数据类型的参数，
并且必须返回<type>cstring</type>类型。输出函数不会被使用 NULL 调用。
</para>

  <!--
<para>
   The optional <replaceable class="parameter">receive_function</replaceable>
   converts the type's external binary representation to the internal
   representation.  If this function is not supplied, the type cannot
   participate in binary input.  The binary representation should be
   chosen to be cheap to convert to internal form, while being reasonably
   portable.  (For example, the standard integer data types use network
   byte order as the external binary representation, while the internal
   representation is in the machine's native byte order.)  The receive
   function should perform adequate checking to ensure that the value is
   valid.
   The receive function can be declared as taking one argument of type
   <type>internal</type>, or as taking three arguments of types
   <type>internal</type>, <type>oid</type>, <type>integer</type>.
   The first argument is a pointer to a <type>StringInfo</type> buffer
   holding the received byte string; the optional arguments are the
   same as for the text input function.
   The receive function must return a value of the data type itself.
   Usually, a receive function should be declared STRICT; if it is not,
   it will be called with a NULL first parameter when reading a NULL
   input value.  The function must still return NULL in this case, unless
   it raises an error.
   (This case is mainly meant to support domain receive functions, which
   might need to reject NULL inputs.)
   Similarly, the optional
   <replaceable class="parameter">send_function</replaceable> converts
   from the internal representation to the external binary representation.
   If this function is not supplied, the type cannot participate in binary
   output.  The send function must be
   declared as taking one argument of the new data type.
   The send function must return type <type>bytea</type>.
   Send functions are not invoked for NULL values.
  </para>
-->
<para>
可选的<replaceable class="parameter">receive_function</replaceable>
把该类型的外部二进制表现形式转换成内部表现形式。如果没有提供这个函数，
那么该类型不能用二进制输入。二进制格式应该选取那种比较容易转换同时
还有一定移植性的内部格式。比如，标准的整数数据类型使用网络字节序作为
外部的二进制表现形式，而内部表现形式则是机器的本机字节序。例如，
接收函数应该声明为接受一个类型为<type>internal</type>的参数，
或者是三个类型分别为<type>internal</type>、<type>oid</type>、
<type>integer</type>的参数。第一个参数是一个指向一个<type>StringInfo</type>
缓冲区的、保存接受字节串的指针；可选的参数和文本输入函数一样。
接收函数必须返回一个该类型的数据值。通常接收函数应当被声明为 STRICT ，
否则否则当读取 NULL 输入时将被使用第一个参数为 NULL 进行调用，
并且必须仍然返回 NULL 或报错。这个特性主要是为了支持域接收函数，
这种函数可能需要拒绝 NULL 输入。同样，可选的
<replaceable class="parameter">send_function</replaceable>
把类型的内部表现形式转换为外部二进制表现形式。如果没有提供这些函数，
那么类型就不能用二进制方式输出。
发送函数必须声明为接收一个新数据类型并且必须返回<type>bytea</type>结果。
发送函数不会被以 NULL 值调用。
</para>

  <!--
<para>
   You should at this point be wondering how the input and output functions
   can be declared to have results or arguments of the new type, when they
   have to be created before the new type can be created.  The answer is that
   the type should first be defined as a <firstterm>shell type</>, which is a
   placeholder type that has no properties except a name and an owner.  This
   is done by issuing the command <literal>CREATE TYPE
   <replaceable>name</></literal>, with no additional parameters.  Then the
   I/O functions can be defined referencing the shell type.  Finally,
   <command>CREATE TYPE</> with a full definition replaces the shell entry
   with a complete, valid type definition, after which the new type can be
   used normally.
  </para>
-->
<para>
这个时候你应该觉得奇怪，输入和输出函数怎么可以声明为返回新类型的结果或者是接受新类型的参数，
而且是在新类型创建之前就需要创建它们。答案是类型必须被首先定义为一个<firstterm>壳类型</>，
它只是一个除了名称和属主之外没有其他属性的占位符类型。这可以通过没有其他额外参数的
<literal>CREATE TYPE <replaceable>name</></literal>命令来完成。
然后就可以引用该壳类型定义输入输出函数。最后，<command>CREATE TYPE</>
把这个壳类型替换成完整的、有效的类型定义，这样就可以使用新类型了。
</para>

  <!--
<para>
   The optional
   <replaceable class="parameter">type_modifier_input_function</replaceable>
   and <replaceable class="parameter">type_modifier_output_function</replaceable>
   are needed if the type supports modifiers, that is optional constraints
   attached to a type declaration, such as <literal>char(5)</> or
   <literal>numeric(30,2)</>.  <productname>PostgreSQL</productname> allows
   user-defined types to take one or more simple constants or identifiers as
   modifiers.  However, this information must be capable of being packed into a
   single non-negative integer value for storage in the system catalogs.  The
   <replaceable class="parameter">type_modifier_input_function</replaceable>
   is passed the declared modifier(s) in the form of a <type>cstring</>
   array.  It must check the values for validity (throwing an error if they
   are wrong), and if they are correct, return a single non-negative
   <type>integer</> value that will be stored as the column <quote>typmod</>.
   Type modifiers will be rejected if the type does not have a
   <replaceable class="parameter">type_modifier_input_function</replaceable>.
   The <replaceable class="parameter">type_modifier_output_function</replaceable>
   converts the internal integer typmod value back to the correct form for
   user display.  It must return a <type>cstring</> value that is the exact
   string to append to the type name; for example <type>numeric</>'s
   function might return <literal>(30,2)</>.
   It is allowed to omit the
   <replaceable class="parameter">type_modifier_output_function</replaceable>,
   in which case the default display format is just the stored typmod integer
   value enclosed in parentheses.
  </para>
-->
<para>
如果支持类型修饰符，那么可选的
<replaceable class="parameter">type_modifier_input_function</replaceable>
和<replaceable class="parameter">type_modifier_output_function</replaceable>
是需要的，这是附属于类型声明的可选的约束，如<literal>char(5)</>和
<literal>numeric(30,2)</>。<productname>PostgreSQL</productname>
允许用户定义的类型接受一个或多个简单的约束或标识符作为修饰符。不过，
这个信息必须能够装进一个非负的整型值里，以在系统表中存储。
<replaceable class="parameter">type_modifier_input_function</replaceable>
以<type>cstring</>数组的形式传送声明的修饰符。它必须检查值的有效性
（如果值是错误的则抛出一个错误），如果是正确的，则返回一个非负的
<type>integer</>值，该值将被作为字段<quote>typmod</>存储。如果类型没有
<replaceable class="parameter">type_modifier_input_function</replaceable>，
那么类型修饰符将被拒绝。<replaceable class="parameter">type_modifier_output_function</replaceable>
转换内部的整数typmod值为用户显示的正确形式。它必须返回一个<type>cstring</>
值，该值是附加到类型名之后的准确的字符串；如<type>numeric</>的函数返回<literal>(30,2)</>。
允许省略<replaceable class="parameter">type_modifier_output_function</replaceable>，
省略的情况下，缺省显示形式是只有存储的typmod整型值包含在圆括号中。
</para>

  <!--
<para>
   The optional <replaceable class="parameter">analyze_function</replaceable>
   performs type-specific statistics collection for columns of the data type.
   By default, <command>ANALYZE</> will attempt to gather statistics using
   the type's <quote>equals</> and <quote>less-than</> operators, if there
   is a default b-tree operator class for the type.  For non-scalar types
   this behavior is likely to be unsuitable, so it can be overridden by
   specifying a custom analysis function.  The analysis function must be
   declared to take a single argument of type <type>internal</>, and return
   a <type>boolean</> result.  The detailed API for analysis functions appears
   in <filename>src/include/commands/vacuum.h</>.
  </para>
-->
<para>
可选的<replaceable class="parameter">analyze_function</replaceable>
为该数据类型的字段执行与该类型相关的统计信息收集。缺省时，
如果该类型有个缺省的 B-tree 操作符类，那么<command>ANALYZE</>
将尝试使用该类型的<quote>等于</>和<quote>小于</>操作符收集信息。
对于非标量类型，这种行为很可能不合适，因此可以通过提供一个自定义的分析函数覆盖它。
分析函数必须声明为接收单独一个<type>internal</>类型的参数，
并且返回一个<type>boolean</>结果。分析函数的详细 API 在
<filename>src/include/commands/vacuum.h</>里。
</para>

  <!--
<para>
   While the details of the new type's internal representation are only
   known to the I/O functions and other functions you create to work with
   the type, there are several properties of the internal representation
   that must be declared to <productname>PostgreSQL</productname>.
   Foremost of these is
   <replaceable class="parameter">internallength</replaceable>.
   Base data types can be fixed-length, in which case
   <replaceable class="parameter">internallength</replaceable> is a
   positive integer, or variable  length, indicated by setting
   <replaceable class="parameter">internallength</replaceable>
   to <literal>VARIABLE</literal>.  (Internally, this is represented
   by setting <literal>typlen</> to -1.)  The internal representation of all
   variable-length types must start with a 4-byte integer giving the total
   length of this value of the type.
  </para>
-->
<para>
尽管新类型的内部表现形式只有输入输出函数和其它你创建来使用该类型的函数了解，
但内部表现形式还是有几个属性必须为<productname>PostgreSQL</productname>声明。
<replaceable class="parameter">internallength</replaceable>是最重要的一个。
基本数据类型可定义成为定长，这时<replaceable class="parameter">internallength</replaceable>
是一个正整数，也可以是变长的，通过把<replaceable class="parameter">internallength</replaceable>
设为<literal>VARIABLE</literal>表示。(在内部，这个状态是通过将<literal>typlen</>
设置为-1 实现的。)所有变长类型的内部形式都必须以一个四字节整数开头，
这个整数给出此类型这个数值的全长。
</para>

  <!--
<para>
   The optional flag <literal>PASSEDBYVALUE</literal> indicates that
   values of this data type are passed by value, rather than by
   reference.  You cannot pass by value types whose internal
   representation is larger than the size of the <type>Datum</> type
   (4 bytes on most machines, 8 bytes on a few).
  </para>
-->
<para>
可选的标记<literal>PASSEDBYVALUE</literal>表明该类型的数值是按值而不是引用传递。
你不能传递那些内部形式大于<type>Datum</>类型尺寸(大多数机器上是 4 字节，
有些是 8 字节)的数据类型的值。
</para>

  <!--
<para>
   The <replaceable class="parameter">alignment</replaceable> parameter
   specifies the storage alignment required for the data type.  The
   allowed values equate to alignment on 1, 2, 4, or 8 byte boundaries.
   Note that variable-length types must have an alignment of at least
   4, since they necessarily contain an <type>int4</> as their first component.
  </para>
-->
<para>
<replaceable class="parameter">alignment</replaceable>参数声明该数据类型要求的对齐存储方式。
允许的数值等效于按照 1, 2, 4, 8 字节边界对齐。请注意变长类型必须有至少 4 字节的对齐，
因为它们必须包含一个<type>int4</>作为第一个部分。
</para>

  <!--
<para>
   The <replaceable class="parameter">storage</replaceable> parameter
   allows selection of storage strategies for variable-length data
   types.  (Only <literal>plain</literal> is allowed for fixed-length
   types.)  <literal>plain</literal> specifies that data of the type
   will always be stored in-line and not compressed.
   <literal>extended</literal> specifies that the system will first
   try to compress a long data value, and will move the value out of
   the main table row if it's still too long.
   <literal>external</literal> allows the value to be moved out of the
   main table, but the system will not try to compress it.
   <literal>main</literal> allows compression, but discourages moving
   the value out of the main table.  (Data items with this storage
   strategy might still be moved out of the main table if there is no
   other way to make a row fit, but they will be kept in the main
   table preferentially over <literal>extended</literal> and
   <literal>external</literal> items.)
  </para>
-->
<para>
<replaceable class="parameter">storage</replaceable>
参数允许为变长数据类型选择存储策略(定长类型只允许使用<literal>plain</literal>)。
<literal>plain</literal>声明该数据类型总是用内联的方式而不是压缩的方式存储。
<literal>extended</literal>声明系统将首先试图压缩一个长的数据值，
然后如果它仍然太长的话就将它的值移出主表，但系统将不会压缩它。
<literal>external</literal>声明禁止系统进行压缩并且允许将它的值移出主表。
<literal>main</literal>允许压缩，但是不赞成把数值移动出主表(如果实在不能放在一行里的话，
仍将移动出主表，它比<literal>extended</literal>和<literal>external</literal>项更愿意保存在主表里)。
</para>

  <!--
<para>
   The <replaceable class="parameter">like_type</replaceable> parameter
   provides an alternative method for specifying the basic representation
   properties of a data type: copy them from some existing type. The values of
   <replaceable class="parameter">internallength</replaceable>,
   <replaceable class="parameter">passedbyvalue</replaceable>,
   <replaceable class="parameter">alignment</replaceable>, and
   <replaceable class="parameter">storage</replaceable> are copied from the
   named type.  (It is possible, though usually undesirable, to override
   some of these values by specifying them along with the <literal>LIKE</>
   clause.)  Specifying representation this way is especially useful when
   the low-level implementation of the new type <quote>piggybacks</> on an
   existing type in some fashion.
  </para>
-->
<para>
<replaceable class="parameter">like_type</replaceable>
参数为指定数据类型的基本代表属性提供一个可选的方式：从某些现有的类型中拷贝他们。
<replaceable class="parameter">internallength</replaceable>、
<replaceable class="parameter">passedbyvalue</replaceable>、
<replaceable class="parameter">alignment</replaceable>和
<replaceable class="parameter">storage</replaceable>的值从命名的类型中拷贝。
（这是可能的，尽管通常不需要，通过和<literal>LIKE</>子句一起指定他们，
来覆盖一些这些值。）这种方式指定代表，在新类型<quote>piggybacks</>
的低级实现以某种方式在现有类型上时尤其有用。
</para>

  <!--
<para>
   The <replaceable class="parameter">category</replaceable> and
   <replaceable class="parameter">preferred</replaceable> parameters can be
   used to help control which implicit cast will be applied in ambiguous
   situations.  Each data type belongs to a category named by a single ASCII
   character, and each type is either <quote>preferred</> or not within its
   category.  The parser will prefer casting to preferred types (but only from
   other types within the same category) when this rule is helpful in
   resolving overloaded functions or operators.  For more details see <xref
   linkend="typeconv">.  For types that have no implicit casts to or from any
   other types, it is sufficient to leave these settings at the defaults.
   However, for a group of related types that have implicit casts, it is often
   helpful to mark them all as belonging to a category and select one or two
   of the <quote>most general</> types as being preferred within the category.
   The <replaceable class="parameter">category</replaceable> parameter is
   especially useful when adding a user-defined type to an existing built-in
   category, such as the numeric or string types.  However, it is also
   possible to create new entirely-user-defined type categories.  Select any
   ASCII character other than an upper-case letter to name such a category.
  </para>
-->
<para>
<replaceable class="parameter">category</replaceable>和
<replaceable class="parameter">preferred</replaceable>
参数可以用于帮助控制哪个隐式转换将被用于模糊的情况。
每个数据类型都属于一个由单个ASCII字符命名的类，并且每个类型不是<quote>preferred</>
就是不在它的类中。当这个规则对于解析重载函数或操作符有帮助时，
解析器更愿意转换为优先的类型（但是只限于来自不在相同类中的其他类型）。
更多信息请参阅<xref linkend="typeconv">。对于没有隐式转换到或来自任意其他类型的类型，
保留这些设置作为缺省就足够了。不过，对于有隐式转换的的相关类型的组，
通常标记他们都属于一个类并且在该类中选取一个或两个<quote>最一般</>
的类型作为优先是有帮助的。当添加一个用户定义的类型到一个现有的内建类时，
<replaceable class="parameter">category</replaceable>参数尤其有用，
如数值型或字符串类型。但是，也有可能创建新的完全用户定义的类型类别。
选取任意ASCII字符而不是一个大写的字母来命名这样一个类别。
</para>

  <!--
<para>
   A default value can be specified, in case a user wants columns of the
   data type to default to something other than the null value.
   Specify the default with the <literal>DEFAULT</literal> key word.
   (Such a default can be overridden by an explicit <literal>DEFAULT</literal>
   clause attached to a particular column.)
  </para>
-->
<para>
如果用户希望字段的数据类型缺省时不是 NULL ，那么可以在<literal>DEFAULT</literal>
关键字里声明一个缺省值(可以被附着在特定字段上的<literal>DEFAULT</literal>子句覆盖)。
</para>

  <!--
<para>
   To indicate that a type is an array, specify the type of the array
   elements using the <literal>ELEMENT</> key word.  For example, to
   define an array of 4-byte integers (<type>int4</type>), specify
   <literal>ELEMENT = int4</literal>. More details about array types
   appear below.
  </para>
-->
<para>
用<literal>ELEMENT</>关键字声明数组元素的类型。
比如，<literal>ELEMENT = int4</literal>定义了一个 4 字节整数
(<type>int4</type>)的数组。有关数组类型的更多细节在下面描述。
</para>

  <!--
<para>
   To indicate the delimiter to be used between values in the external
   representation of arrays of this type, <replaceable
   class="parameter">delimiter</replaceable> can be
   set to a specific character.  The default delimiter is the comma
   (<literal>,</literal>).  Note that the delimiter is associated
   with the array element type, not the array type itself.
  </para>
-->
<para>
可用<replaceable class="parameter">delimiter</replaceable>
指定用于这种类型数组的外部形式的数值之间的分隔符。
缺省的分隔符是逗号(<literal>,</literal>)。
请注意分隔符是和数组元素类型相关联，而不是数组类型本身。
</para>

  <!--
<para>
   If the optional Boolean
   parameter <replaceable class="parameter">collatable</replaceable>
   is true, column definitions and expressions of the type may carry
   collation information through use of
   the <literal>COLLATE</literal> clause.  It is up to the
   implementations of the functions operating on the type to actually
   make use of the collation information; this does not happen
   automatically merely by marking the type collatable.
  </para>
-->
<para>
如果可选的布尔参数<replaceable class="parameter">collatable</replaceable>为真，
那么该类型的字段定义和表达式可以通过使用<literal>COLLATE</literal>
子句携带排序信息。取决于在该类型上函数操作符的实现，以实际上利用排序信息；
仅仅通过标记该类型可排序，这就不会自动发生。
</para>
  </refsect2>

  <refsect2>
   <!--
   <title>Array Types</title>
   -->
   <title>数组类型</title>

   <!--
<para>
    Whenever a user-defined type is created,
    <productname>PostgreSQL</productname> automatically creates an
    associated array type, whose name consists of the element type's
    name prepended with an underscore, and truncated if necessary to keep
    it less than <symbol>NAMEDATALEN</symbol> bytes long.  (If the name
    so generated collides with an existing type name, the process is
    repeated until a non-colliding name is found.)
    This implicitly-created array type is variable length and uses the
    built-in input and output functions <literal>array_in</> and
    <literal>array_out</>.  The array type tracks any changes in its
    element type's owner or schema, and is dropped if the element type is.
   </para>
-->
<para>
在创建用户定义类型的时候，<productname>PostgreSQL</productname>
自动创建一个与之关联的数组类型，其名字由该元素类型的名字前缀一个下划线组成，
并且如果有必要保持它小于<symbol>NAMEDATALEN</symbol>字节长度时截断。
（如果这样生成的名字与一个现有的类型名冲突，那么重复该进程，
知道找到一个不冲突的名字。）这个隐含创建的数组类型是变长并且使用内建的
<literal>array_in</>和<literal>array_out</>输入和输出函数。
数组类型追踪它的元素类型的所有者或模式的任意更改，
并且如果元素类型有更改时删除。
</para>

   <!--
<para>
    You might reasonably ask why there is an <option>ELEMENT</>
    option, if the system makes the correct array type automatically.
    The only case where it's useful to use <option>ELEMENT</> is when you are
    making a fixed-length type that happens to be internally an array of a number of
    identical things, and you want to allow these things to be accessed
    directly by subscripting, in addition to whatever operations you plan
    to provide for the type as a whole.  For example, type <type>point</>
    is represented as just two floating-point numbers, each can be accessed using
    <literal>point[0]</> and <literal>point[1]</>.
    Note that
    this facility only works for fixed-length types whose internal form
    is exactly a sequence of identical fixed-length fields.  A subscriptable
    variable-length type must have the generalized internal representation
    used by <literal>array_in</> and <literal>array_out</>.
    For historical reasons (i.e., this is clearly wrong but it's far too
    late to change it), subscripting of fixed-length array types starts from
    zero, rather than from one as for variable-length arrays.
   </para>
-->
<para>
你很可能会问如果系统自动制作正确的数组类型，那为什么还要有个<option>ELEMENT</>选项?
使用<option>ELEMENT</>的场合有一：你定义的定长类型碰巧在内部是一个一定数目相同事物的数组，
而你又想允许这 N 个事物可以通过下标直接访问，除了某些操作符将把该类型当做整体进行处理。
比如，类型<type>point</>表示为两个浮点数，每个可以用<literal>point[0]</>
和<literal>point[1]</>访问。请注意这个功能只适用于定长类型，
并且其内部形式是一个相同定长域的序列。一个可以下标化的变长类型必须有被
<literal>array_in</>和<literal>array_out</>使用的一般化的内部表现形式。
出于历史原因（也就是，这是明显错误的，但是要改变它却太晚了），
定长数组类型的下标从 0 开始，而不是像变长数组那样的从 1 开始。
</para>
  </refsect2>
 </refsect1>

 <refsect1>
  <!--
<title>Parameters</title>
-->
<title>参数</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="parameter">name</replaceable></term>
    <listitem>
     <!--
<para>
      The name (optionally schema-qualified) of a type to be created.
     </para>
-->
<para>
将要创建的类型名(可以有模式修饰)
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">attribute_name</replaceable></term>
    <listitem>
     <!--
<para>
      The name of an attribute (column) for the composite type.
     </para>
-->
<para>
复合类型的一个属性(字段)的名字
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">data_type</replaceable></term>
    <listitem>
     <!--
<para>
      The name of an existing data type to become a column of the
      composite type.
     </para>
-->
<para>
要成为一个复合类型的字段的现有数据类型的名字
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">collation</replaceable></term>
    <listitem>
     <!--
<para>
      The name of an existing collation to be associated with a column of
      a composite type, or with a range type.
     </para>
-->
<para>
与复合类型或范围类型字段有关的现有排序的名字
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">label</replaceable></term>
    <listitem>
     <!--
<para>
      A string literal representing the textual label associated with
      one value of an enum type.
     </para>
-->
<para>
表示与枚举类型的值有关的文本标签的字符串字面值
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">subtype</replaceable></term>
    <listitem>
     <!--
<para>
      The name of the element type that the range type will represent ranges
      of.
     </para>
-->
<para>
元素类型的名字，范围类型将代表的范围
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">subtype_operator_class</replaceable></term>
    <listitem>
     <!--
<para>
      The name of a b-tree operator class for the subtype.
     </para>
-->
<para>
该子类型的b-tree操作符类的名字
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">canonical_function</replaceable></term>
    <listitem>
     <!--
<para>
      The name of the canonicalization function for the range type.
     </para>
-->
<para>
范围类型的标准化函数的名字
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">subtype_diff_function</replaceable></term>
    <listitem>
     <!--
<para>
      The name of a difference function for the subtype.
     </para>
-->
<para>
子类型的差异函数的名字
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">input_function</replaceable></term>
    <listitem>
     <!--
<para>
      The name of a function that converts data from the type's
      external textual form to its internal form.
     </para>
-->
<para>
一个函数的名称，将数据从外部文本形式转换成内部格式。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">output_function</replaceable></term>
    <listitem>
     <!--
<para>
      The name of a function that converts data from the type's
      internal form to its external textual form.
     </para>
-->
<para>
一个函数的名称，将数据从内部格式转换成适于显示的外部文本形式。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">receive_function</replaceable></term>
    <listitem>
     <!--
<para>
      The name of a function that converts data from the type's
      external binary form to its internal form.
     </para>
-->
<para>
一个函数的名称，把数据从类型的外部二进制形式转换成内部形式
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">send_function</replaceable></term>
    <listitem>
     <!--
<para>
      The name of a function that converts data from the type's
      internal form to its external binary form.
     </para>
-->
<para>
一个函数的名称，把数据从类型的内部形式转换成外部二进制形式
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">type_modifier_input_function</replaceable></term>
    <listitem>
     <!--
<para>
      The name of a function that converts an array of modifier(s) for the type
      into internal form.
     </para>
-->
<para>
一个函数的名称，把修饰符的数组类型转换成内部形式
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">type_modifier_output_function</replaceable></term>
    <listitem>
     <!--
<para>
      The name of a function that converts the internal form of the type's
      modifier(s) to external textual form.
     </para>
-->
<para>
一个函数的名称，把类型的修饰符的内部形式转换成外部形式
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">analyze_function</replaceable></term>
    <listitem>
     <!--
<para>
      The name of a function that performs statistical analysis for the
      data type.
     </para>
-->
<para>
为该数据类型执行统计分析的函数名
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">internallength</replaceable></term>
    <listitem>
     <!--
<para>
      A numeric constant that specifies the length in bytes of the new
      type's internal representation.  The default assumption is that
      it is variable-length.
     </para>
-->
<para>
一个数值常量，说明新类型的内部表现形式的字节长度。缺省假定它是变长的。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">alignment</replaceable></term>
    <listitem>
     <!--
<para>
      The storage alignment requirement of the data type.  If specified,
      it must be <literal>char</literal>, <literal>int2</literal>,
      <literal>int4</literal>, or <literal>double</literal>; the
      default is <literal>int4</literal>.
     </para>
-->
<para>
该数据类型的存储对齐要求。如果声明了，必须是<literal>char</literal>、
<literal>int2</literal>、<literal>int4</literal>(缺省)、<literal>double</literal>之一。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">storage</replaceable></term>
    <listitem>
     <!--
<para>
      The storage strategy for the data type.  If specified, must be
      <literal>plain</literal>, <literal>external</literal>,
      <literal>extended</literal>, or <literal>main</literal>; the
      default is <literal>plain</literal>.
     </para>
-->
<para>
该数据类型的存储策略。如果声明了，必须是<literal>plain</literal>(缺省)、
<literal>external</literal>、<literal>extended</literal>、<literal>main</literal>之一。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">like_type</replaceable></term>
    <listitem>
     <!--
<para>
      The name of an existing data type that the new type will have the
      same representation as.  The values of
      <replaceable class="parameter">internallength</replaceable>,
      <replaceable class="parameter">passedbyvalue</replaceable>,
      <replaceable class="parameter">alignment</replaceable>, and
      <replaceable class="parameter">storage</replaceable>
      are copied from that type, unless overridden by explicit
      specification elsewhere in this <command>CREATE TYPE</> command.
     </para>
-->
<para>
与新类型将要有的表现相同的现有数据类型的名字。
<replaceable class="parameter">internallength</replaceable>、
<replaceable class="parameter">passedbyvalue</replaceable>、
<replaceable class="parameter">alignment</replaceable>、
<replaceable class="parameter">storage</replaceable>的值是从该类型中拷贝的，
除非在<command>CREATE TYPE</>命令中明确的说明覆写。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">category</replaceable></term>
    <listitem>
     <!--
<para>
      The category code (a single ASCII character) for this type.
      The default is <literal>'U'</> for <quote>user-defined type</>.
      Other standard category codes can be found in
      <xref linkend="catalog-typcategory-table">.  You may also choose
      other ASCII characters in order to create custom categories.
     </para>
-->
<para>
这个类型的类别代码（单个ASCII字符）。<quote>用户定义类型</>却省是<literal>'U'</>。
其他标准类别代码可以在<xref linkend="catalog-typcategory-table">中找到。
你也可以选择其他ASCII字符来创建自定义类别。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">preferred</replaceable></term>
    <listitem>
     <!--
<para>
      True if this type is a preferred type within its type category,
      else false.  The default is false.  Be very careful about creating
      a new preferred type within an existing type category, as this
      could cause surprising changes in behavior.
     </para>
-->
<para>
如果这个类型在它的类型类别中是首选类型则为真，否则为假。缺省是假。
在一个现有的类型类别中创建一个新的首选类型时要非常小心，
因为这会导致行为上意外的变化。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">default</replaceable></term>
    <listitem>
     <!--
<para>
      The default value for the data type.  If this is omitted, the
      default is null.
     </para>
-->
<para>
该类型的缺省值。若省略则为 NULL
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">element</replaceable></term>
    <listitem>
     <!--
<para>
      The type being created is an array; this specifies the type of
      the array elements.
     </para>
-->
<para>
被创建的类型是数组；这个声明数组元素的类型。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">delimiter</replaceable></term>
    <listitem>
     <!--
<para>
      The delimiter character to be used between values in arrays made
      of this type.
     </para>
-->
<para>
数组元素之间分隔符
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">collatable</replaceable></term>
    <listitem>
     <!--
<para>
      True if this type's operations can use collation information.
      The default is false.
     </para>
-->
<para>
如果这个类型的操作可以使用排序信息则为真。缺省为假。
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1 id="SQL-CREATETYPE-notes">
  <!--
<title>Notes</title>
-->
<title>注意</title>

  <!--
<para>
   Because there are no restrictions on use of a data type once it's been
   created, creating a base type or range type is tantamount to granting
   public execute permission on the functions mentioned in the type definition.
   This is usually
   not an issue for the sorts of functions that are useful in a type
   definition.  But you might want to think twice before designing a type
   in a way that would require <quote>secret</> information to be used
   while converting it to or from external form.
  </para>
-->
<para>
因为一旦类型被创建之后对它的使用就没有限制，
所以创建一个基本类型或范围类型就等价于授予所有用户执行类型定义中指定的各个函数的权限，
这对于大多数类型定义中指定的函数来说不会造成什么不良问题。
但是如果你设计的新类型在内部形式和外部形式之间转换的时候使用<quote>敏感信息</>，
那么你仍然要再三考虑、多加小心。
</para>

  <!--
<para>
   Before <productname>PostgreSQL</productname> version 8.3, the name of
   a generated array type was always exactly the element type's name with one
   underscore character (<literal>_</literal>) prepended.  (Type names were
   therefore restricted in length to one less character than other names.)
   While this is still usually the case, the array type name may vary from
   this in case of maximum-length names or collisions with user type names
   that begin with underscore.  Writing code that depends on this convention
   is therefore deprecated.  Instead, use
   <structname>pg_type</>.<structfield>typarray</> to locate the array type
   associated with a given type.
  </para>
-->
<para>
<productname>PostgreSQL</productname>版本8.3之前，
生成的数组类型的名字总是正好是元素类型的名字前置一个下划线字符(<literal>_</literal>)。
（因此限制类型名字的长度比其他名字的字符要少。）虽然这仍然是通常的情况，
但是数组类型名字可能会有变化，假使最大长度名字或与下划线开始的用户类型名字冲突。
依赖于这个约定的书写代码因此弃用了。取而代之，使用<structname>pg_type</>.<structfield>typarray</>
来定位与一个给定类型相关的数组类型。
</para>

  <!--
<para>
   It may be advisable to avoid using type and table names that begin with
   underscore.  While the server will change generated array type names to
   avoid collisions with user-given names, there is still risk of confusion,
   particularly with old client software that may assume that type names
   beginning with underscores always represent arrays.
  </para>
-->
<para>
避免使用以下划线开始的类型和表名是明智的。虽然服务器将改变生成的数组类型名，
以避免与用户给定的名字冲突，但是仍然有混淆的更显，
尤其是老的客户端软件可能假设以下划线开始的类型名总是代表数组。
</para>

  <!--
<para>
   Before <productname>PostgreSQL</productname> version 8.2, the shell-type
   creation syntax
   <literal>CREATE TYPE <replaceable>name</></literal> did not exist.
   The way to create a new base type was to create its input function first.
   In this approach, <productname>PostgreSQL</productname> will first see
   the name of the new data type as the return type of the input function.
   The shell type is implicitly created in this situation, and then it
   can be referenced in the definitions of the remaining I/O functions.
   This approach still works, but is deprecated and might be disallowed in
   some future release.  Also, to avoid accidentally cluttering
   the catalogs with shell types as a result of simple typos in function
   definitions, a shell type will only be made this way when the input
   function is written in C.
  </para>
-->
<para>
<productname>PostgreSQL</productname>版本8.2之前，壳类型创建语法
<literal>CREATE TYPE <replaceable>name</></literal>并不存在。
创建新的基本类型之前必须首先创建其输入函数。这样，<productname>PostgreSQL</productname>
将会首先把新类型的名字看作输入函数的返回类型并隐含创建壳类型，
然后这个壳类型将被随后定义的输入输出函数引用。这种老式的方法目前仍然被支持，
但已经反对使用，将来可能不再支持。同样，为了避免函数定义中的临时壳类型偶然地搞乱系统表，
当输入函数用 C 语言书写时，将只能用这种方法创建壳类型。
</para>

  <!--
<para>
   In <productname>PostgreSQL</productname> versions before 7.3, it
   was customary to avoid creating a shell type at all, by replacing the
   functions' forward references to the type name with the placeholder
   pseudotype <type>opaque</>.  The <type>cstring</> arguments and
   results also had to be declared as <type>opaque</> before 7.3.  To
   support loading of old dump files, <command>CREATE TYPE</> will
   accept I/O functions declared using <type>opaque</>, but it will issue
   a notice and change the function declarations to use the correct
   types.
  </para>
-->
<para>
在<productname>PostgreSQL</productname> 7.3 以前，要通过使用占位伪类型
<type>opaque</>代替函数的前向引用来避免创建壳类型。7.3 之前<type>cstring</>
参数和结果同样需要声明为<type>opaque</>。要支持加载旧的转储文件，
<command>CREATE TYPE</>将接受那些用<type>opaque</>声明的输入输出函数，
但是它将发出一条通知并且用正确的类型改变函数的声明。
</para>

 </refsect1>

 <refsect1>
  <!--
<title>Examples</title>
-->
<title>例子</title>

  
<para>
<!--
   This example creates a composite type and uses it in
   a function definition:
-->
这个例子创建一个复合类型并且在一个函数定义中使用它：
<programlisting>
CREATE TYPE compfoo AS (f1 int, f2 text);

CREATE FUNCTION getfoo() RETURNS SETOF compfoo AS $$
    SELECT fooid, fooname FROM foo
$$ LANGUAGE SQL;
</programlisting>
  </para>
  
<para>
<!--
   This example creates an enumerated type and uses it in
   a table definition:
-->
这个命令创建枚举类型，并且将它用于一个表定义：
<programlisting>
CREATE TYPE bug_status AS ENUM ('new', 'open', 'closed');

CREATE TABLE bug (
    id serial,
    description text,
    status bug_status
);
</programlisting>
  </para>
  
<para>
<!--
   This example creates a range type:
-->
这个例子创建一个范围类型：
<programlisting>
CREATE TYPE float8_range AS RANGE (subtype = float8, subtype_diff = float8mi);
</programlisting>
  </para>

  
<para>
<!--
   This example creates the base data type <type>box</type> and then uses the
   type in a table definition:
-->
这个命令创建<type>box</type>基本数据类型，并且将这种类型用于一个表定义：
<programlisting>
CREATE TYPE box;

CREATE FUNCTION my_box_in_function(cstring) RETURNS box AS ... ;
CREATE FUNCTION my_box_out_function(box) RETURNS cstring AS ... ;

CREATE TYPE box (
    INTERNALLENGTH = 16,
    INPUT = my_box_in_function,
    OUTPUT = my_box_out_function
);

CREATE TABLE myboxes (
    id integer,
    description box
);
</programlisting>
  </para>
  
<para>
<!--
   If the internal structure of <type>box</type> were an array of four
   <type>float4</> elements, we might instead use:
-->
如果<type>box</type>的内部结构是一个四个<type>float4</>的数组，可以使用：
<programlisting>
CREATE TYPE box (
    INTERNALLENGTH = 16,
    INPUT = my_box_in_function,
    OUTPUT = my_box_out_function,
    ELEMENT = float4
);
</programlisting>
<!-- 
   which would allow a box value's component numbers to be accessed
   by subscripting.  Otherwise the type behaves the same as before. 
-->
来允许一个 box 的数值成分成员可以用下标访问。否则该类型和前面的行为一样。
  </para>

  
<para>
<!--
   This example creates a large object type and uses it in
   a table definition:
-->
这条命令创建一个大对象类型并将其用于一个表定义：
<programlisting>
CREATE TYPE bigobj (
    INPUT = lo_filein, OUTPUT = lo_fileout,
    INTERNALLENGTH = VARIABLE
);
CREATE TABLE big_objs (
    id integer,
    obj bigobj
);
</programlisting>
  </para>
  <!--
<para>
   More examples, including suitable input and output functions, are
   in <xref linkend="xtypes">.
  </para>
-->
<para>
更多的例子，包括合适的输入和输出函数，位于<xref linkend="xtypes">。
</para>
 </refsect1>

 <refsect1 id="SQL-CREATETYPE-compatibility">
  <!--
<title>Compatibility</title>
-->
<title>兼容性</title>

  <!--
<para>
   The first form of the <command>CREATE TYPE</command> command, which
   creates a composite type, conforms to the <acronym>SQL</> standard.
   The other forms are <productname>PostgreSQL</productname>
   extensions.  The <command>CREATE TYPE</command> statement in
   the <acronym>SQL</> standard also defines other forms that are not
   implemented in <productname>PostgreSQL</>.
  </para>
-->
<para>
<command>CREATE TYPE</command>命令的第一种形式，创建一个复合类型，
符合<acronym>SQL</>标准。其他形式是<productname>PostgreSQL</productname>
的扩展。<acronym>SQL</>标准中的<command>CREATE TYPE</command>
语句也定义了没有在<productname>PostgreSQL</>中实现的其他形式。
</para>

  <!--
<para>
   The ability to create a composite type with zero attributes is
   a <productname>PostgreSQL</productname>-specific deviation from the
   standard (analogous to the same case in <command>CREATE TABLE</command>).
  </para>
-->
<para>
用0属性创建一个复合类型的能力是<productname>PostgreSQL</productname>
与标准具体的偏差（类似于<command>CREATE TABLE</command>中的相同情况）。
</para>
 </refsect1>

 <refsect1 id="SQL-CREATETYPE-see-also">
  <!--
<title>See Also</title>
-->
<title>又见</title>

  <simplelist type="inline">
   <member><xref linkend="sql-altertype"></member>
   <member><xref linkend="sql-createdomain"></member>
   <member><xref linkend="sql-createfunction"></member>
   <member><xref linkend="sql-droptype"></member>
  </simplelist>
 </refsect1>

</refentry>
